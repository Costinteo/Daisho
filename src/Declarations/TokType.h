// THIS FILE GENERATED BY GenTokType.py. DO NOT EDIT.
#ifndef INCLUDE_TOKENS
#define INCLUDE_TOKENS
#include <apaz-libc.h>

#define NUM_TOKTYPES 80
enum TokType {
  INVALID,
  END_OF_FILE,
  IMPORT,
  COMMENT,
  IDENT,
  NATIVE,
  CTYPE,
  BOOL,
  CHAR,
  UCHAR,
  SHORT,
  USHORT,
  INT,
  UINT,
  LONG,
  FLOAT,
  DOUBLE,
  VOID,
  IF,
  ELSE,
  FOR,
  WHILE,
  CONTINUE,
  BREAK,
  IN,
  CLASS,
  THIS,
  OPERATOR,
  EXTENDS,
  TRAIT,
  IMPL,
  ENUM,
  PRIVATE,
  PROTECTED,
  PUBLIC,
  SUPER,
  INSTANCEOF,
  SIZEOF,
  ASSERT,
  LPAREN,
  RPAREN,
  LBRACE,
  RBRACE,
  LBRACK,
  RBRACK,
  LARROW,
  RARROW,
  SEMI,
  COMMA,
  DOT,
  STAR,
  EQUALS,
  BANG,
  TILDE,
  QUESTION,
  COLON,
  EQUAL,
  LE,
  GE,
  NOTEQUAL,
  AND,
  OR,
  INC,
  DEC,
  ADD,
  SUB,
  DIV,
  AMP,
  BITOR,
  CARET,
  MOD,
  ARROW,
  ADD_ASSIGN,
  SUB_ASSIGN,
  MUL_ASSIGN,
  DIV_ASSIGN,
  AND_ASSIGN,
  OR_ASSIGN,
  XOR_ASSIGN,
  MOD_ASSIGN,
};
typedef enum TokType TokType;
static const char* TokNameMap[] = {
  "INVALID", 
  "END_OF_FILE", 
  "IMPORT", 
  "COMMENT", 
  "IDENT", 
  "NATIVE", 
  "CTYPE", 
  "BOOL", 
  "CHAR", 
  "UCHAR", 
  "SHORT", 
  "USHORT", 
  "INT", 
  "UINT", 
  "LONG", 
  "FLOAT", 
  "DOUBLE", 
  "VOID", 
  "IF", 
  "ELSE", 
  "FOR", 
  "WHILE", 
  "CONTINUE", 
  "BREAK", 
  "IN", 
  "CLASS", 
  "THIS", 
  "OPERATOR", 
  "EXTENDS", 
  "TRAIT", 
  "IMPL", 
  "ENUM", 
  "PRIVATE", 
  "PROTECTED", 
  "PUBLIC", 
  "SUPER", 
  "INSTANCEOF", 
  "SIZEOF", 
  "ASSERT", 
  "LPAREN", 
  "RPAREN", 
  "LBRACE", 
  "RBRACE", 
  "LBRACK", 
  "RBRACK", 
  "LARROW", 
  "RARROW", 
  "SEMI", 
  "COMMA", 
  "DOT", 
  "STAR", 
  "EQUALS", 
  "BANG", 
  "TILDE", 
  "QUESTION", 
  "COLON", 
  "EQUAL", 
  "LE", 
  "GE", 
  "NOTEQUAL", 
  "AND", 
  "OR", 
  "INC", 
  "DEC", 
  "ADD", 
  "SUB", 
  "DIV", 
  "AMP", 
  "BITOR", 
  "CARET", 
  "MOD", 
  "ARROW", 
  "ADD_ASSIGN", 
  "SUB_ASSIGN", 
  "MUL_ASSIGN", 
  "DIV_ASSIGN", 
  "AND_ASSIGN", 
  "OR_ASSIGN", 
  "XOR_ASSIGN", 
  "MOD_ASSIGN"
};

static inline TokType valid_NATIVE(char* str) { return apaz_str_equals(str, "native") ? NATIVE : INVALID; }
static inline TokType valid_CTYPE(char* str) { return apaz_str_equals(str, "ctype") ? CTYPE : INVALID; }
static inline TokType valid_BOOL(char* str) { return apaz_str_equals(str, "Bool") ? BOOL : INVALID; }
static inline TokType valid_CHAR(char* str) { return apaz_str_equals(str, "Char") ? CHAR : INVALID; }
static inline TokType valid_UCHAR(char* str) { return apaz_str_equals(str, "UChar") ? UCHAR : INVALID; }
static inline TokType valid_SHORT(char* str) { return apaz_str_equals(str, "Short") ? SHORT : INVALID; }
static inline TokType valid_USHORT(char* str) { return apaz_str_equals(str, "UShort") ? USHORT : INVALID; }
static inline TokType valid_INT(char* str) { return apaz_str_equals(str, "Int") ? INT : INVALID; }
static inline TokType valid_UINT(char* str) { return apaz_str_equals(str, "UInt") ? UINT : INVALID; }
static inline TokType valid_LONG(char* str) { return apaz_str_equals(str, "Long") ? LONG : INVALID; }
static inline TokType valid_FLOAT(char* str) { return apaz_str_equals(str, "Float") ? FLOAT : INVALID; }
static inline TokType valid_DOUBLE(char* str) { return apaz_str_equals(str, "Double") ? DOUBLE : INVALID; }
static inline TokType valid_VOID(char* str) { return apaz_str_equals(str, "Void") ? VOID : INVALID; }
static inline TokType valid_IF(char* str) { return apaz_str_equals(str, "if") ? IF : INVALID; }
static inline TokType valid_ELSE(char* str) { return apaz_str_equals(str, "else") ? ELSE : INVALID; }
static inline TokType valid_FOR(char* str) { return apaz_str_equals(str, "for") ? FOR : INVALID; }
static inline TokType valid_WHILE(char* str) { return apaz_str_equals(str, "while") ? WHILE : INVALID; }
static inline TokType valid_CONTINUE(char* str) { return apaz_str_equals(str, "continue") ? CONTINUE : INVALID; }
static inline TokType valid_BREAK(char* str) { return apaz_str_equals(str, "break") ? BREAK : INVALID; }
static inline TokType valid_IN(char* str) { return apaz_str_equals(str, "in") ? IN : INVALID; }
static inline TokType valid_CLASS(char* str) { return apaz_str_equals(str, "class") ? CLASS : INVALID; }
static inline TokType valid_THIS(char* str) { return apaz_str_equals(str, "this") ? THIS : INVALID; }
static inline TokType valid_OPERATOR(char* str) { return apaz_str_equals(str, "operator") ? OPERATOR : INVALID; }
static inline TokType valid_EXTENDS(char* str) { return apaz_str_equals(str, "extends") ? EXTENDS : INVALID; }
static inline TokType valid_TRAIT(char* str) { return apaz_str_equals(str, "trait") ? TRAIT : INVALID; }
static inline TokType valid_IMPL(char* str) { return apaz_str_equals(str, "impl") ? IMPL : INVALID; }
static inline TokType valid_ENUM(char* str) { return apaz_str_equals(str, "enum") ? ENUM : INVALID; }
static inline TokType valid_PRIVATE(char* str) { return apaz_str_equals(str, "private") ? PRIVATE : INVALID; }
static inline TokType valid_PROTECTED(char* str) { return apaz_str_equals(str, "protected") ? PROTECTED : INVALID; }
static inline TokType valid_PUBLIC(char* str) { return apaz_str_equals(str, "public") ? PUBLIC : INVALID; }
static inline TokType valid_SUPER(char* str) { return apaz_str_equals(str, "super") ? SUPER : INVALID; }
static inline TokType valid_INSTANCEOF(char* str) { return apaz_str_equals(str, "instanceof") ? INSTANCEOF : INVALID; }
static inline TokType valid_SIZEOF(char* str) { return apaz_str_equals(str, "sizeof") ? SIZEOF : INVALID; }
static inline TokType valid_ASSERT(char* str) { return apaz_str_equals(str, "assert") ? ASSERT : INVALID; }
static inline TokType valid_LPAREN(char* str) { return apaz_str_equals(str, "(") ? LPAREN : INVALID; }
static inline TokType valid_RPAREN(char* str) { return apaz_str_equals(str, ")") ? RPAREN : INVALID; }
static inline TokType valid_LBRACE(char* str) { return apaz_str_equals(str, "{") ? LBRACE : INVALID; }
static inline TokType valid_RBRACE(char* str) { return apaz_str_equals(str, "}") ? RBRACE : INVALID; }
static inline TokType valid_LBRACK(char* str) { return apaz_str_equals(str, "[") ? LBRACK : INVALID; }
static inline TokType valid_RBRACK(char* str) { return apaz_str_equals(str, "]") ? RBRACK : INVALID; }
static inline TokType valid_LARROW(char* str) { return apaz_str_equals(str, "<") ? LARROW : INVALID; }
static inline TokType valid_RARROW(char* str) { return apaz_str_equals(str, ">") ? RARROW : INVALID; }
static inline TokType valid_SEMI(char* str) { return apaz_str_equals(str, ";") ? SEMI : INVALID; }
static inline TokType valid_COMMA(char* str) { return apaz_str_equals(str, ",") ? COMMA : INVALID; }
static inline TokType valid_DOT(char* str) { return apaz_str_equals(str, ".") ? DOT : INVALID; }
static inline TokType valid_STAR(char* str) { return apaz_str_equals(str, "*") ? STAR : INVALID; }
static inline TokType valid_EQUALS(char* str) { return apaz_str_equals(str, "=") ? EQUALS : INVALID; }
static inline TokType valid_BANG(char* str) { return apaz_str_equals(str, "!") ? BANG : INVALID; }
static inline TokType valid_TILDE(char* str) { return apaz_str_equals(str, "~") ? TILDE : INVALID; }
static inline TokType valid_QUESTION(char* str) { return apaz_str_equals(str, "?") ? QUESTION : INVALID; }
static inline TokType valid_COLON(char* str) { return apaz_str_equals(str, ":") ? COLON : INVALID; }
static inline TokType valid_EQUAL(char* str) { return apaz_str_equals(str, "==") ? EQUAL : INVALID; }
static inline TokType valid_LE(char* str) { return apaz_str_equals(str, "<=") ? LE : INVALID; }
static inline TokType valid_GE(char* str) { return apaz_str_equals(str, ">=") ? GE : INVALID; }
static inline TokType valid_NOTEQUAL(char* str) { return apaz_str_equals(str, "!=") ? NOTEQUAL : INVALID; }
static inline TokType valid_AND(char* str) { return apaz_str_equals(str, "&&") ? AND : INVALID; }
static inline TokType valid_OR(char* str) { return apaz_str_equals(str, "||") ? OR : INVALID; }
static inline TokType valid_INC(char* str) { return apaz_str_equals(str, "++") ? INC : INVALID; }
static inline TokType valid_DEC(char* str) { return apaz_str_equals(str, "--") ? DEC : INVALID; }
static inline TokType valid_ADD(char* str) { return apaz_str_equals(str, "+") ? ADD : INVALID; }
static inline TokType valid_SUB(char* str) { return apaz_str_equals(str, "-") ? SUB : INVALID; }
static inline TokType valid_DIV(char* str) { return apaz_str_equals(str, "/") ? DIV : INVALID; }
static inline TokType valid_AMP(char* str) { return apaz_str_equals(str, "&") ? AMP : INVALID; }
static inline TokType valid_BITOR(char* str) { return apaz_str_equals(str, "|") ? BITOR : INVALID; }
static inline TokType valid_CARET(char* str) { return apaz_str_equals(str, "^") ? CARET : INVALID; }
static inline TokType valid_MOD(char* str) { return apaz_str_equals(str, "%") ? MOD : INVALID; }
static inline TokType valid_ARROW(char* str) { return apaz_str_equals(str, "->") ? ARROW : INVALID; }
static inline TokType valid_ADD_ASSIGN(char* str) { return apaz_str_equals(str, "+=") ? ADD_ASSIGN : INVALID; }
static inline TokType valid_SUB_ASSIGN(char* str) { return apaz_str_equals(str, "-=") ? SUB_ASSIGN : INVALID; }
static inline TokType valid_MUL_ASSIGN(char* str) { return apaz_str_equals(str, "*=") ? MUL_ASSIGN : INVALID; }
static inline TokType valid_DIV_ASSIGN(char* str) { return apaz_str_equals(str, "/=") ? DIV_ASSIGN : INVALID; }
static inline TokType valid_AND_ASSIGN(char* str) { return apaz_str_equals(str, "&=") ? AND_ASSIGN : INVALID; }
static inline TokType valid_OR_ASSIGN(char* str) { return apaz_str_equals(str, "|=") ? OR_ASSIGN : INVALID; }
static inline TokType valid_XOR_ASSIGN(char* str) { return apaz_str_equals(str, "^=") ? XOR_ASSIGN : INVALID; }
static inline TokType valid_MOD_ASSIGN(char* str) { return apaz_str_equals(str, "%=") ? MOD_ASSIGN : INVALID; }
static inline bool potential_NATIVE(char* str) { return apaz_str_startsWith("native", str); }
static inline bool potential_CTYPE(char* str) { return apaz_str_startsWith("ctype", str); }
static inline bool potential_BOOL(char* str) { return apaz_str_startsWith("Bool", str); }
static inline bool potential_CHAR(char* str) { return apaz_str_startsWith("Char", str); }
static inline bool potential_UCHAR(char* str) { return apaz_str_startsWith("UChar", str); }
static inline bool potential_SHORT(char* str) { return apaz_str_startsWith("Short", str); }
static inline bool potential_USHORT(char* str) { return apaz_str_startsWith("UShort", str); }
static inline bool potential_INT(char* str) { return apaz_str_startsWith("Int", str); }
static inline bool potential_UINT(char* str) { return apaz_str_startsWith("UInt", str); }
static inline bool potential_LONG(char* str) { return apaz_str_startsWith("Long", str); }
static inline bool potential_FLOAT(char* str) { return apaz_str_startsWith("Float", str); }
static inline bool potential_DOUBLE(char* str) { return apaz_str_startsWith("Double", str); }
static inline bool potential_VOID(char* str) { return apaz_str_startsWith("Void", str); }
static inline bool potential_IF(char* str) { return apaz_str_startsWith("if", str); }
static inline bool potential_ELSE(char* str) { return apaz_str_startsWith("else", str); }
static inline bool potential_FOR(char* str) { return apaz_str_startsWith("for", str); }
static inline bool potential_WHILE(char* str) { return apaz_str_startsWith("while", str); }
static inline bool potential_CONTINUE(char* str) { return apaz_str_startsWith("continue", str); }
static inline bool potential_BREAK(char* str) { return apaz_str_startsWith("break", str); }
static inline bool potential_IN(char* str) { return apaz_str_startsWith("in", str); }
static inline bool potential_CLASS(char* str) { return apaz_str_startsWith("class", str); }
static inline bool potential_THIS(char* str) { return apaz_str_startsWith("this", str); }
static inline bool potential_OPERATOR(char* str) { return apaz_str_startsWith("operator", str); }
static inline bool potential_EXTENDS(char* str) { return apaz_str_startsWith("extends", str); }
static inline bool potential_TRAIT(char* str) { return apaz_str_startsWith("trait", str); }
static inline bool potential_IMPL(char* str) { return apaz_str_startsWith("impl", str); }
static inline bool potential_ENUM(char* str) { return apaz_str_startsWith("enum", str); }
static inline bool potential_PRIVATE(char* str) { return apaz_str_startsWith("private", str); }
static inline bool potential_PROTECTED(char* str) { return apaz_str_startsWith("protected", str); }
static inline bool potential_PUBLIC(char* str) { return apaz_str_startsWith("public", str); }
static inline bool potential_SUPER(char* str) { return apaz_str_startsWith("super", str); }
static inline bool potential_INSTANCEOF(char* str) { return apaz_str_startsWith("instanceof", str); }
static inline bool potential_SIZEOF(char* str) { return apaz_str_startsWith("sizeof", str); }
static inline bool potential_ASSERT(char* str) { return apaz_str_startsWith("assert", str); }
static inline bool potential_LPAREN(char* str) { return apaz_str_startsWith("(", str); }
static inline bool potential_RPAREN(char* str) { return apaz_str_startsWith(")", str); }
static inline bool potential_LBRACE(char* str) { return apaz_str_startsWith("{", str); }
static inline bool potential_RBRACE(char* str) { return apaz_str_startsWith("}", str); }
static inline bool potential_LBRACK(char* str) { return apaz_str_startsWith("[", str); }
static inline bool potential_RBRACK(char* str) { return apaz_str_startsWith("]", str); }
static inline bool potential_LARROW(char* str) { return apaz_str_startsWith("<", str); }
static inline bool potential_RARROW(char* str) { return apaz_str_startsWith(">", str); }
static inline bool potential_SEMI(char* str) { return apaz_str_startsWith(";", str); }
static inline bool potential_COMMA(char* str) { return apaz_str_startsWith(",", str); }
static inline bool potential_DOT(char* str) { return apaz_str_startsWith(".", str); }
static inline bool potential_STAR(char* str) { return apaz_str_startsWith("*", str); }
static inline bool potential_EQUALS(char* str) { return apaz_str_startsWith("=", str); }
static inline bool potential_BANG(char* str) { return apaz_str_startsWith("!", str); }
static inline bool potential_TILDE(char* str) { return apaz_str_startsWith("~", str); }
static inline bool potential_QUESTION(char* str) { return apaz_str_startsWith("?", str); }
static inline bool potential_COLON(char* str) { return apaz_str_startsWith(":", str); }
static inline bool potential_EQUAL(char* str) { return apaz_str_startsWith("==", str); }
static inline bool potential_LE(char* str) { return apaz_str_startsWith("<=", str); }
static inline bool potential_GE(char* str) { return apaz_str_startsWith(">=", str); }
static inline bool potential_NOTEQUAL(char* str) { return apaz_str_startsWith("!=", str); }
static inline bool potential_AND(char* str) { return apaz_str_startsWith("&&", str); }
static inline bool potential_OR(char* str) { return apaz_str_startsWith("||", str); }
static inline bool potential_INC(char* str) { return apaz_str_startsWith("++", str); }
static inline bool potential_DEC(char* str) { return apaz_str_startsWith("--", str); }
static inline bool potential_ADD(char* str) { return apaz_str_startsWith("+", str); }
static inline bool potential_SUB(char* str) { return apaz_str_startsWith("-", str); }
static inline bool potential_DIV(char* str) { return apaz_str_startsWith("/", str); }
static inline bool potential_AMP(char* str) { return apaz_str_startsWith("&", str); }
static inline bool potential_BITOR(char* str) { return apaz_str_startsWith("|", str); }
static inline bool potential_CARET(char* str) { return apaz_str_startsWith("^", str); }
static inline bool potential_MOD(char* str) { return apaz_str_startsWith("%", str); }
static inline bool potential_ARROW(char* str) { return apaz_str_startsWith("->", str); }
static inline bool potential_ADD_ASSIGN(char* str) { return apaz_str_startsWith("+=", str); }
static inline bool potential_SUB_ASSIGN(char* str) { return apaz_str_startsWith("-=", str); }
static inline bool potential_MUL_ASSIGN(char* str) { return apaz_str_startsWith("*=", str); }
static inline bool potential_DIV_ASSIGN(char* str) { return apaz_str_startsWith("/=", str); }
static inline bool potential_AND_ASSIGN(char* str) { return apaz_str_startsWith("&=", str); }
static inline bool potential_OR_ASSIGN(char* str) { return apaz_str_startsWith("|=", str); }
static inline bool potential_XOR_ASSIGN(char* str) { return apaz_str_startsWith("^=", str); }
static inline bool potential_MOD_ASSIGN(char* str) { return apaz_str_startsWith("%=", str); }

/**********/
/* Custom */
/**********/


static inline TokType validImport(char *str) {
  return String_equals(str, "include") || String_equals(str, "import")
             ? IMPORT
             : INVALID;
}

static inline bool potentialImport(char *str) {
  return apaz_str_startsWith("import", str) ||
         apaz_str_startsWith("include", str);
}

static inline TokType validIdent(char *str) {
  for (size_t i = 0; i < String_len(str); i++) {
    if ((str[i] != ' ') &
        (str[i] != '\t') &
        (str[i] != '\r') &
        (str[i] != '\n'))
      return INVALID;
  }
  return IDENT;
}

static inline bool potentialIdent(char *str) { }

static inline TokType validComment(char *str) {
  if (apaz_strlen(str) < 3)
    return INVALID;
  else if (String_startsWith(str, "/*") && String_endsWith(str, "*/")) {
    size_t search_end = apaz_strlen(str) - 4; // Prefix/suffix
    str = str + 2;
    for (size_t i = 0; i < search_end; i++)
      if (str[i] == '*' & str[i + 1] == '/')
        return INVALID;
    return COMMENT;
  } else if (String_startsWith(str, "//") && String_endsWith(str, "\n")) {
    size_t search_end = apaz_strlen(str) - 3; // -3 for prefix/suffix
    str = str + 2;
    for (size_t i = 0; i < search_end; i++)
      if (str[i] == '\n')
        return INVALID;
    return COMMENT;
  }
  return INVALID;
}

static inline bool potentialComment(char *str) {
  bool sl = apaz_str_startsWith(str, "//");
  bool ml = apaz_str_startsWith(str, "/*");
  if (!(sl | ml))
    return false;

  size_t len = apaz_strlen(str);
  if (sl) {
    for (size_t i = 2; i < len - 1; i++)
      if (str[i] == '\n')
        return false;
    return true;
  } else {
    for (size_t i = 2; i < len - 2; i++)
      if (str[i] == '*' & str[i + 1] == '/')
        return false;
    return true;
  }
}


#endif // INCLUDE_TOKENS